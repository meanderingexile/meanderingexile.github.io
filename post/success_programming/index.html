<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<title>Life After Segfaults - meanderingexile</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="description"
    content="Software can crash, but systems should be trying to succeed. ">
<link rel="canonical" href="http://localhost:1313/post/success_programming/" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.1.0/modern-normalize.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />



<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link rel="preload" as="style"
      href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Noto+Emoji&display=swap" />
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Noto+Emoji&display=swap"
      media="print" onload="this.media='all'" />
<noscript>
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" />
</noscript>



<link rel="stylesheet" href="/css/hugo-tufte.min.css">



<link rel="stylesheet" href="/css/hugo-tufte-options.min.css">

<link rel="stylesheet" href="/css/hugo-tufte-override.css">

</head>
<body>


<article id="main">
  <section>
<h1 class="content-title">Life After Segfaults</h1></section>

  

  <section><p>Frequently, when I travel, I end up at some point on a week/poor internet
connection, and I spend a lot of time looking at the words &ldquo;Hmm. We’re having
trouble finding that site.&rdquo; As I sit there, I wonder: why am I seeing this?
More specifically, why is it up to me to manually hit the &ldquo;refresh&rdquo; button?
This feeling repeats, often with growing frustration, across apps and services
as downloads, sessions, and tasks fail and time-out.</p>
<p>I&rsquo;m not a browser engineer, and I respect how deep a problem space it is. You
probably don&rsquo;t want a misconfigured client hammering a server with repeated
HTTP requests that will never fail, or unexpectedly re-triggering a download
that was meant to happen on Wi-Fi on mobile data instead. When enough time,
money, and energy are involved, the correct risk management decision is to
escalate to a person, because a person can be sued.</p>
<p><img src="/images/computer_management.jpg" alt=""></p>
<p>My suspicion, though, is that most of the time, designers aren&rsquo;t thinking in
terms of risk management at all. Instead, I think it comes down to two things:
the natural tendency to focus on one&rsquo;s area of speciality, and the software
engineering wisdom of &ldquo;crash early, crash often&rdquo; being misapplied at the wrong
level of abstraction.</p>
<p>The idea of &ldquo;crash early, crash often&rdquo; comes about because of the mind-boggling
complexity of software. The act of executing essentially any modern piece of
software involves an almost incomprehensible number of degrees of freedom- not
simply the variables in the code, but the possible states of every bit of
memory, executed within and managed by an operating system, which in turn is
just as likely to be virtualized- you get the idea. The set of states that we
can reason about well, let alone actually do productive work in, is a
Cantor dust within this gigantic state space.</p>
<p><a href="https://medium.com/@mattklein123/crash-early-and-crash-often-for-more-reliable-software-597738dd21c5">Matt Klein&rsquo;s article</a>
has a good discussion of how crashing helps manage complexity. It is,
effectively, a heuristic in the Gigerenzer sense: we only need a single binary
cue to act on. Once we detect that a program has wandered outside acceptable
bounds into here-be-dragons, we immediately know what to do, and don&rsquo;t waste
time trying to navigate our way back to known space. This saves effort: maybe
computational effort (running some careful validation process) but more likely
engineering effort. Time spent developing complex error handling logic to
recover a thread of execution is engineering time that could often be spent
more productively somewhere else.</p>
<blockquote cite="Crash%20early%20and%20crash%20often%20for%20more%20reliable%20software">
<p>What happens if the programmer is incorrect and an assertion is not valid in
all cases? Let the program crash! Like the null check in the previous section,
an assertion failure is trivial to debug. The fix may either be to remove the
assertion and add handling code, or to make the calling code adhere to the
assertion.</p>

<footer>Matt Klein, <cite>Crash early and crash often for more reliable software</cite></footer>
</blockquote>

<p>This is all well and good from the software&rsquo;s perspective, but crashes do have
a fundamental flaw, which is surprisingly easy to overlook when you&rsquo;re just
focused on writing good software: the job&rsquo;s not done. Someone presumably
triggered your software to achieve an objective, and that objective hasn&rsquo;t been
met.</p>
<p>Klein is, I assume, well aware of this. His article primarily talks about
the experience from the developer side, and how assertions can make code easier
to debug. The implied context, though, is made explicit in the linked
documentation from Envoy, a project Klein developed at Lyft:</p>
<blockquote cite="https://github.com/envoyproxy/envoy/blob/main/STYLE.md#error-handling">
<p>The &ldquo;less is more&rdquo; error handling philosophy described in the previous points is primarily based on the fact that restarts are designed to be fast, reliable and cheap.</p>

<footer>Envoy Documentation, <cite><a href="https://github.com/envoyproxy/envoy/blob/main/STYLE.md#error-handling">https://github.com/envoyproxy/envoy/blob/main/STYLE.md#error-handling</a></cite></footer>
</blockquote>

<p>The system is not the software. In this particular case, the software is one
part of a much more complicated system of DevOps infrastructure, monitoring,
and control. Crashing is not an end state, but a tool: by crashing and
restarting, we return to a known location in parameter space, and can set out
again with confidence. A particular instance of the software crashes, but the
system still moves toward the goal.</p>
<p>What I see in consumer software, with a surprising level of frequency, is this
general crash-first approach . The software &ldquo;fails successfully&rdquo;: an error
message is displayed, and the programmer&rsquo;s job is done, but the task isn&rsquo;t
finished.</p>
<p>Effectively, the system here has become a two-part one: the software, and a
manual human operator, who assumes responsibility for the decision to continue.
In an ideal world, we picture this person as an engineer in a nuclear reactor
control room, with their whole focus</p>
</section>
  <section><footer class="page-footer">
<hr />

<div class="previous-post" style="display:inline-block;">
  
  <a class="link-reverse" href="http://localhost:1313/post/reframing/?ref=footer">« Reframing Anxiety</a>
  
</div>

<div class="next-post", style="display:inline-block;float:right;">
  
  <a class="link-reverse" href="http://localhost:1313/post/volcanology/?ref=footer">Amateur Volcanology »</a>
  
</div>

<ul class="page-footer-menu">
  
  
  <li><a href="https://twitter.com/meanderingexile">Twitter</a></li>
  

  

  

  

  

  

  

  

  

  

  
  <li><a href="https://instance.url/@username">Mastodon</a></li>
  

  

  
  
  
</ul>


<p>
  Powered by <a href="https://gohugo.io">Hugo</a> and the
  <a href="https://github.com/loikein/hugo-tufte">Tufte theme</a>.
</p>




</footer>
</section>
  <section><nav class="menu">
    <ul>
    
        <li><a href="/"><i class='fas fa-home la-lg'></i>Home</a></li>
    
        <li><a href="/post"><i class='fas fa-book fa-lg'></i> Posts</a></li>
    
        <li><a href="/categories"><i class='fas fa-tags fa-lg'></i> Categories</a></li>
    
        <li><a href="/about"><i class='fas fa-info-circle  fa-lg'></i> About</a></li>
    
    </ul>
</nav>
</section>
</article>





</body>

</html>
